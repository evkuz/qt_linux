#ifndef EVKUZ_H
#define EVKUZ_H
/*
 * 26.04.2022 Начало проекта
 *
 * Ветка dobot. Стационарный манипулятор Dobot Magician
 * Для начала GUI, робот новый, сложный.
 *
 * Команда GetPose help
 * https://jacquesjohnston.wordpress.com/2019/01/29/communicating-with-the-dobot-magician-using-raw-protocol/
 *
 * Конвертер float to hex. Remember that Little Endian data are coming from Dobot.
 * https://gregstoll.com/~gregstoll/floattohex/
 *
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 17.07.2022
 * J2 & J3 зависят друг от друга.
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 16.06.2022
 * Сейчас ptpMode == JUMP_XYZ
 * А надо попробовать JUMP_MOVL_XYZ == 0x09, // JUMP mode, (x,y,z,r) is the Cartesian coordinate increment in Cartesian coordinate system
 * ...
 * Попробовал, есть разница. НАдо разбираться с этими режимами.
 * Сделать отдельную вкладку для JOG-позиций.
 *
 * Надо попробовать запустить проект DobotDemoForQt
 * //+++++++++++++++++++++++++++++++++++++
 * 15.06.2022
 * Добавлена ф-ция dobotCommands::getCRC(unsigned char *arr, int size)
 * Добавил кнопку "ToHOMeButton" - возвращает робота из позиции  (X: 250, Y: 150, Z: 50, R: 150)
 * в позицию HOME == (X: 250, Y: 150, Z: 49.749, R: 150)
 * Видим стабильное отклонение Z от значения 50.0 - это будет отдельная задача.
 * Теперь по кнопкам "SpecPoseButton" <-> "ToHOMeButton" можно гонять Dobot туда-сюда, появилась наглядность.
 * C появлением подсчета CRC изменена схема отправки команд.
 * В массив на отправку добавляем все данные без CRC, вычисяем CRC, добавляем CRC к данным на отправку.
 * .... блин, пока записывал понял, что тогда на каждую команду нужен свой массив crcSource(все кроме CRC)...
 * В общем надо массив crcSource делать динамическим и данные для него программно выцеплять из positions.h
 * ...
 * Обошлись без динамического массива.
 * Теперь в статическом массиве храним только заголовки команд - 5-6 байт.
 * Далее данные на отправку добавляем в создаваемый налету массмв QByteArray.
 * Команды позиционирования получают данные для координат налету, их нет в массиве.
 *
 * - По нажатию кнопки "XAdd10Button" отправляется GetPose, получаем ответ,
 *   вычисляются текущие координаты, к координате Х добавляем 10.0.
 * - Получаем новые значения для XYZR - они ВСЕ меняются из-за смены Х.
 * - Формируем команду на отправку:
 *      - добавляем заголовок в массив QByteArray (arr)
 *      - берем заголовок, из него вынимаем в отдельный массив (arr2) данные для CRC - ID, Ctrl(2 байта)
 *      + данные в arr2, причём тут обратное преобразование float -> QByteArray через ф-цию
 *        dobotCommands::floatToQByteArray(QByteArray *arr, float *val),
 *      + вычисляем CRC
 *      + добавляем CRC к посылке (arr), отправляем SetPTPCmd
 *
 * РАБОТАЕТ :)
 * С остальными командами - не позиционирование - еще проще, т.к. меньше данных.
 *
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 14.06.2022
 * Есть предупреждение при сборке библиотеки DobotDll.h
 * ‘void QTime::start()’ is deprecated: Use QElapsedTimer instead [-Wdeprecated-declarations]
 *
 * Имеет смысл на досуге разобраться, может поэтому и не работает WAIT_CMD_EXECUTION();
 * Также выяснилось, что есть 2 библиотеки для Magician - multi, master. Т.е. когда роботов несколько, либо когда один.
 * Когда несколько, то во всех ф-циях добавлен параметр dbtID - номер девайса, который можно задаваить и по которому они
 * различаются внутри программы.
 * Пока все эти библиотеки отключены, никакого API.
 * Используем только Communication Protocol.
 *
 * Пилим дальше парсер.
 * ...
 * Получил заветную строчку : "0x1331: From Parser X = 150.209"
 *
 * workflow следующий :
 * - В ф-ции dobotCommands::parseData(QByteArray &data)
 *   Задаем число quint32 temp = 0x43163583; - float в формате BigEndian
 * - Задаем public значение float *XX как XX = reinterpret_cast<float*>(&temp);
 * - В лог пишем значение QString::number(*protocolDobot->XX);
 *
 * Теперь надо довести до ума dobotCommands::parseData(QByteArray &data).
 * ...
 * Довёл. Можно работать.
 *
 * Теперь надо создавать корректировщика позиции.
 * Т.к. вскрылась интересная ситуация.
 *
 * 1. Задаем через SetPTPCmd (ID 84) по кнопке "SpecPoseButton" позицию (X: 250, Y: 150, Z: 50, R: 150), дожидаемся завершения.
 * 2. Считываем текущую позицию через getPose получаем X: 250, Y: 150, Z: 49.749, R: 150
 *    Т.е. в позиции Z у нас ошибка аж на 0.251 Всего
 *
 * Т.е. нужно добавить кнопки +/-X, +/-Y, +/-Z
 *
 * Также, пожалуй, стоит каждый раз при запуске команды SetPTPCmd (ID 84), либо GetPose сохранять полученные значения
 * где-то в массиве, по аналогии с Servos для HiWonder
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 11.06.2022
 * Делаем парсер команды.
 * В первую очередь нужен для команды GetPose, чтобы извлекать из hex-данных float-значения координат.
 * Создаю класс dobotCommands:: где будет вся работа связанная с подготовкой данных на отправку роботу,
 * либо же чтение данных, полученных от робота и парсинг оных.
 *
 * Не работает штатный WAIT_CMD_EXECUTION();
 * Выдает левые данные.
 *
 * Проинициализировал данными структуру Pose mypose;
 * Так вот после вызова GetPose(Pose *pose) ф-ция отрабатывает без ошибок, но данные возвращает, те, которыми была
 * проинициализирована структура Pose mypose. Т.е реально GetPose(Pose *pose) НЕ отрабатывает.
 * //+++++++++++++++++++++++++++++++++++++
 * 10.06.2022
 * Добавляем команды движения.
 *
 * - When controlling the Dobot, the Dobot controller will update the real-time pose based on the
 *   reference value and the real-time motion status.
 * - PTP mode supports MOVJ, MOVL, and JUMP, which is point-to-point movement.
 *
 * Проверил работу библиотечной ф-ции int GetPose(int dobotId, Pose *pose) - Хрен там.
 * Через Communication Protocol - norm.
 * Также пошла команда SetPTPCmd (ID 84)
 *
 *
 * Задача :
 * - ДОбавляем файл для работы с данными Dobot. Наверное, даже отдельный класс надо.
 * - Конвертация hex-данных во float и далее в децимал.
 * - Выцеплять из посылки от робота float данные для координат xyzr, выводить их в исходном и десятичном виде.
 * Исключить подключение к НЕ Dobot Magician
 *
 *
 *
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 08.06.2022
 * Разобрался с протоколом.
 * Заявленная ф-ция API int GetDeviceName(int dobotId, char *deviceName, uint32_t maxLen) отрабатывает
 * без ошибок, но данные в массиве deviceName - непонятно, есть ли они там.
 * По логике работы ф-ции имя девайса должно быть в массиве deviceName, но там пусто.
 * Либо, я что-то так и не понял.
 * Однако...
 * Если Задействовать Communication Protocol, то можно использовать эту ф-цию.
 * Только надо правильно задать все поля посылки.
 * Долго промучился с формированием посылки.
 * Ошибок было 2 :
 * - забывал прибавить к R значения ID + Ctrl
 * - Ctrl - это 1 байт, а я разбивал его на 2, т.е. отдельно rw и isQueued, а надо в одном байте.
 *
 * Также поправил в классе SerialDevice вывод hex-данных в ф-ции SerialDevice::ReadFromSerial_Slot()
 * Теперь при выводе понятно, что это hex-данные, т.к. имеют вид 0xaa, 0x0a, 0x01, 0x00, 0x49, 0x51, 0x52, 0x4a
 * Так проверил работку команд SetDeviceName, GetDeviceName.
 *
 * ТАкже поправил ф-цию Robot::GoToPosition(QByteArray &position)
 * Теперь работает с массивом QByteArray &position разного размера, т.к. в этом роботе размер посылки может меняться.
 * Фиксим.
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 07.06.2022
 * Подключил библиотеку DOBOTDLL_H
 * Проверил работу ф-ций :
 * - SearchDobot
 * - GetDeviceSN
 * - SetDeviceName
 * - GetDeviceName
 *
 * Все отработали без ошибок, но GetDeviceName выводит пустоту...
 * ВАЖНО !
 * При этом подключение к роботу осталось через Dobot->Open_Port_Slot
 * НАжатие кнопки "HOME" также работает.
 * Непонятно назначение ф-ции
 * int ConnectDobot(const char *portName, uint32_t baudrate, char *fwType, char *version float *time)
 *
 * ЗАметим, что нужна инициализация указателей на массив char *, даже если он заполняется самой вызываемой ф-цией
 *
 * Следующим шагом пробуем Jogging
 * //+++++++++++++++++++++++++++++++++++++
 * 06.06.2022
 * Заработало.
 * dobot реагирует на команду
 * {0xaa, 0xaa, 0x03, 0x1f, 0x00, 0x00, 0xe1}
 * Это "home" + CRC.
 * Пора переносить это в GUI-приложение.
 * ...
 * Создал GUI.
 * Фиксируем.
 *
 * Пробуем подключить библиотеки
 * ...
 * Хрен там.
 * Очень много нестыковок.
 * //+++++++++++++++++++++++++++++++++++++
 * 27.04.2022
 * Заработало !
 * HiWonder принимает команды.
 * Соединение сигнала QSerialPort::readyRead() со слотом SerialDevice::ReadFromSerial_Slot() сделано в конструкторе  класса SerialDevice.
 * Так в основном файле проекта (mainprocess.cpp) не будет этой строки, меньше кода.
 * Теперь надо:
 * + Дбавить запись в лог ответа от робота.
 * - Разобраться с дублированием записи :
 * "0xf001: Robot finished
 *  0xf001: Robot finished complex command
 * "
 * - Добавить работу с TCP/ip
 * - ДОбавить парсинг JSON-данных
 *
 *
 * //+++++++++++++++++++++++++++++++++++++
 * 26.04.2022
 *
 * Выстраиваем иерархию объекта через несколько классов.
 * Класс SerialDevice - аналог HiWonder, но без привязки к имени собственному. ОБъекты, например, - Nano, Mega - по названию плат.
 * Класс Robot (Manipulator) - Дочерний от SerialDevice. Вот тут уже свойства робота можно описывать - DOF, parcel_size и т.д. Объекты - HiWonder, Mobman, Pinkman  - по названию робота.
 * Далее к объекту класса Robot надо прикручивать связь с другими роботами - создавать объект класса QTcpServer, работа с потоками, парсинг JSON и т.д.
 *
 * Создал класс SerialDevice - общий класс для устройств QSerialPort
 * Создал класс MainProcess - где будет основной поток программы
 *
 *
 *
 *
*/

#endif // EVKUZ_H
